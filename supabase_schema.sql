-- SQL Migration Script for MicroThreads
-- Run this script in your Supabase SQL Editor

-- 1. Create 'tips' table
CREATE TABLE IF NOT EXISTS public.tips (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    sender TEXT NOT NULL,
    receiver TEXT,
    amount TEXT NOT NULL, -- Storing as text to avoid precision loss with large numbers
    timestamp BIGINT NOT NULL, -- Unix timestamp
    hash TEXT,
    post_id TEXT,
    type TEXT DEFAULT 'sent'::text
);

-- Add indexes for faster querying
CREATE INDEX IF NOT EXISTS tips_sender_idx ON public.tips (sender);
CREATE INDEX IF NOT EXISTS tips_receiver_idx ON public.tips (receiver);
CREATE INDEX IF NOT EXISTS tips_post_id_idx ON public.tips (post_id);

-- 2. Create 'votes' table
CREATE TABLE IF NOT EXISTS public.votes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_address TEXT NOT NULL,
    post_id TEXT NOT NULL,
    creator_address TEXT NOT NULL,
    vote_type TEXT CHECK (vote_type IN ('up', 'down')) NOT NULL,
    UNIQUE(user_address, post_id) -- Prevent multiple votes per user per post
);

CREATE INDEX IF NOT EXISTS votes_post_id_idx ON public.votes (post_id);
CREATE INDEX IF NOT EXISTS votes_user_address_idx ON public.votes (user_address);

-- 3. Create 'bookmarks' table
CREATE TABLE IF NOT EXISTS public.bookmarks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_address TEXT NOT NULL,
    post_id TEXT NOT NULL,
    creator_address TEXT NOT NULL,
    timestamp BIGINT,
    UNIQUE(user_address, post_id) -- Prevent duplicate bookmarks
);

CREATE INDEX IF NOT EXISTS bookmarks_user_address_idx ON public.bookmarks (user_address);

-- 4. Create 'post_views' table for real view counting
CREATE TABLE IF NOT EXISTS public.post_views (
    post_id TEXT PRIMARY KEY,
    view_count BIGINT DEFAULT 0,
    last_updated TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 5. Create function for atomic view increment
CREATE OR REPLACE FUNCTION increment_view_count(p_post_id TEXT)
RETURNS VOID AS $$
BEGIN
  INSERT INTO public.post_views (post_id, view_count, last_updated)
  VALUES (p_post_id, 1, timezone('utc'::text, now()))
  ON CONFLICT (post_id)
  DO UPDATE SET
    view_count = post_views.view_count + 1,
    last_updated = timezone('utc'::text, now());
END;
$$ LANGUAGE plpgsql;

-- 6. Create 'post-media' Storage Bucket
-- Note: You might need to create this manually in the Storage UI if this script fails,
-- but this SQL attempts to create it via the storage schema.

INSERT INTO storage.buckets (id, name, public)
VALUES ('post-media', 'post-media', true)
ON CONFLICT (id) DO NOTHING;

-- 7. Set up RLS Policies for Storage (Optional since we use Admin client now, but good practice)
-- Allow public read access
CREATE POLICY "Public Access"
ON storage.objects FOR SELECT
USING ( bucket_id = 'post-media' );

-- Allow authenticated uploads (if we were using client-side upload)
-- Since we use Admin client server-side, this is strictly optional but helpful if you revert.
CREATE POLICY "Authenticated Uploads"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'post-media' );
